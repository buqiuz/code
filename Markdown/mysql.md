# mysql

## 1.varchar

5.0版本以上，varchar(100)，指的是100字符，无论存放的是数字、字母还是UTF8汉字（每个汉字3字节），都可以存放100个。

## 2.tinyint

1字节，范围-128~127。无符号：0~255

## 3.RBAC思想

Refference:
[一篇文章看懂mysql中varchar能存多少汉字、数字，以及varchar(100)和varchar(10)的区别](https://www.cnblogs.com/zhuyeshen/p/11642211.html)

## B树

![alt text](https://raw.githubusercontent.com/buqiuz/Images/main/image.png)

- 自平衡多路搜索树
- 因为一个节点可以放多个键，所以不需要频繁的平衡
- 2d+1阶B树，则一个节点最少d个键，最多2d个键，分支比键多一个，当键为2d+1后，拆分为两个d的子节点，中间那个键上升为父节点，然后两个子节点放在父节点两边，如果父节点也超过2d+1，则递归。
- 一个B树可以被描述为（d+1~2d+1）树，也可以描述为（2d+1）树。
- 所有叶子节点在相同深度，深度越少，io开销越少，因为不是连续存储，所以每访问下一层都会读进内存一次io操作进行访问，由于一个节点可放多个节点，所以可以在较小的深度存储大量数据。
- 节点内访问时间远小于节点间访问时间，所以最大化节点内的节点数量，最小化树的深度

## B+树

> 可以将任何字段作为关键字，然后建立索引，也就是辅助索引,（与之相对应的是主索引，以主键或非空不重复键建立索引，然后叶子节点指向某一条具体的记录）
> 聚簇索引:数据和索引存储在一起。主索引叶子节点则存储具体的记录，辅助索引则存储主索引的键
> 非聚簇索引:索引和数据是分开的。以主键或非空不重复键建立索引，然后叶子节点(存储地址)指向某一条具体的记录  主索引叶子节点存储某一条记录的地址，辅助索引也是如此。
> innoDB就是聚簇索引，MyISAM就是非聚簇索引，InnoDB是默认推荐引擎，因其事务支持和崩溃恢复能力，而MyISAM逐渐被替代

![alt text](https://raw.githubusercontent.com/buqiuz/Images/main/image-1.png)

- 如果一个m阶的B+树，则除了根节点，所有节点最少m/2个键，最多m-1个键，对于任意节点最多m个子节点，子节点总是比键多一个
- 所有元素都在叶子节点，如果顺序查询则不需要中序遍历（多次io），直接找到需要顺序查询的第一个元素，然后顺序遍历就行，中间节点不存储元素，只存储键。

**在mysql更高的版本，当mysql启动时，会将索引(非叶子节点)加载到内存中，所以，真正的磁盘io只有叶子节点那一次。**

## MyISAM

**叶子节点放地址**
找到地址后回表
![alt text](https://raw.githubusercontent.com/buqiuz/Images/main/image-2.png)

- frm:即帧，存储表结构
- MYD：data，即存储数据
- MyI：index，即索引

当输入一条查询语句时，会先看查询条件是否是索引，是的话就去MYI中查询得到记录的地址，然后去MYD中去获取数据

## innoDB

**叶子节点放具体数据**
![alt text](https://raw.githubusercontent.com/buqiuz/Images/main/image-3.png)

- frm：即帧，存储表结构
- ibd：放索引加叶子放数据

## 事务

> 一系列操作的集合,innoDB能够保障ACID四个特性

- 原子性(Atomicity)：要么全部完成,要么全部失败
  - 通过undo日志,redo日志来保障,事务开始前记录状态到undo日志,若回滚,则通过undo日志回滚,事务提交后,即使系统崩溃,也可以通过redo日志,恢复数据
- 一致性(Consistency)：也就是数据库不会进入非法状态,比如金额凭空丢失,突破完整性约束,比如超卖(库存为负数)
- 隔离性(Isolation)：并发执行时,事务之间不会互相干扰,防止脏读、不可重复读、幻读
  - 未提交读:有脏读问题,会读取到未提交数据,假如事务回滚没提交,则出现读取数据错误
  - 已提交读:需要事务提交后,其他事务才能读取到修改后的数据,但是有不可重复读的问题(一次事务读取同一个数据会出现前后不一致)
  - 可重复读:隔离级别更高,当一个事务读了一个数据后,在后续读取这个数据时,不会出现不一致问题.(也就是事务开始时建立快照,之后读就会读这个快照版本) 幻读问题
    - 通过间隙锁解决插入,行锁解决删除
  - 可串行化:解决所有问题,当事务涉及到某个数据时,会将其锁住,其他事务被阻塞
- 持久性(Durability)：

### MVCC

- 乐观锁: 不要用java中算出来的值进行更新,而是直接从数据库中查询出来进行+ - * / 更新,不然会出bug,
  - 修改时加版本号,检查查询出来的版本和修改的版本是不是一致的,如果不是就回滚,重新查询更新.
- 悲观锁: 不要用java中算出来的值进行更新,而是直接从数据库中查询出来进行+ - * / 更新,不然会出bug,
  - 比如 update user set balance = balance - 300 where id =1;
  - 这样就会加写锁,会读取版本链中最新数据

## 面试

1. 聚集索引和非聚集索引区别是什么？
   1. 只是叶子节点存不存储完整的一条记录的区别，比如MyISAM叶子节点存储的是地址，就是非聚集索引，而innoDB叶子节点存储的是完整的一条记录，就是聚集索引
2. 为什么innoDB建表时推荐建一个主键，而且是整型自增的主键？
   1. 因为innoDB建表时会自动生成一个聚集索引（就是这样设计的），通常会用主键来生成，假如没有主键，则会用一个唯一的键来生成，也没的话就会生成一个隐藏的rowId来生成，所以能自己干的事还是自己来干，如果用rowId，因为不对用户开放，则没办法高效的用主键来查询。
   2. 因为在查找过程中会多次进行大小比较，整型就比较适合，如果用uuid的话，因为uuid比较长，比较大小时若前面很多位相同的话则会花费很多时间，而且uuid存储花费大，int或bigint就小很多。自增是因为每次插入如果不是在末尾插入，而是在中间插入，为了维护B+树结构，需要分裂以及平衡，这些都需要耗费时间，而如果插入到末尾就不会导致索引频繁分裂，而且uuid是随机的，会导致索引碎片化。
   3. 若是分库分表怎么办，如何保证全局主键唯一性？
      1. 使用雪花算法，利用当前时间戳保证整体上是递增的。从而保证全局唯一性
3. 为什么不用Hash索引？
   1. 因为Hash索引无法进行范围查找，进行范围查找时就需要进行全表扫描。
4. 联合索引是什么？
   1. 使用多个字段建立索引，先根据第一个字段进行排序，无法区分时再根据下一个字段排序。
   2. 为什么要使用最左前缀法则？
      1. 因为B+树是先按照第一个字段进行排序，然后依次排序，假如跳过了前面一个字段进行匹配，则无法正确匹配，因为走索引是遍历到某一个值后，后续就不需要再遍历了，而如果不遵守左前缀法则，则遍历到某一个值后，后续可能还有应该找的值，也就是走索引无效了。相当于要全表扫描。一句话：要让第二个字段有序，必须要第一个字段相同，后续同理，所以第二个字段其实是乱序的，也就是无法走索引。排好序是走索引的必要条件。 中间跳一个字段也可以走索引，前面字段走索引，后面字段回表查询
